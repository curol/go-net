package reader

import (
	"bufio"
	"fmt"
	"io"
	"log"
)

// Scan reader and return slice of lines seperated by the delimeter
func Scan(reader io.Reader) [][]byte {
	// Scan input from client
	scanner := bufio.NewScanner(reader)

	// Split the input into lines with the default split function, ScanLines.
	// ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker.
	// The returned line may be empty.
	// The end-of-line marker is one optional carriage return followed by one mandatory newline.
	// In regular expression notation, it is `\r?\n`.
	// The last non-empty line of input will be returned even if it has no newline.
	scanner.Split(bufio.ScanLines)

	// Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method.
	// It returns false when the scan stops, either by reaching the end of the input or an error.
	// After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil.
	// Scan panics if the split function returns too many empty tokens without advancing the input.
	// This is a common error mode for scanners.
	var lines [][]byte
	var isEndOfHead bool
	i := 0
	for scanner.Scan() {
		// Bytes returns the most recent token generated by a call to Scan.
		line := scanner.Bytes()

		// TODO: When head and body received, break
		if len(line) == 0 && isEndOfHead {
			break
		}
		if line == nil || len(line) == 0 {
			break
		}

		// Increment line number
		i++

		// Append line to message
		lines = append(lines, line)

		// Log status
		fmt.Printf("line %d (length: %d): %d", i, len(line), line)
	}

	// Handle error
	if err := scanner.Err(); err != nil {
		log.Println("Error parsing request: ", err)
	}

	// Return message
	return lines
}
